{{define "models.ts"}}
/**
* This file is auto-generated by Napiway. Do not edit this file directly.
* To make changes, edit the template file at generators/typescript/templates/models.ts.tmpl
*/
{{$clientName := .ClientName}}

/**
 * {{$clientName}}Error is a custom error class that encapsulates different types of errors that can occur when using the {{$clientName}} client. It includes a reason for the error, a message, and optionally the underlying error object for more detailed debugging information.
 */
export class {{$clientName}}Error extends Error {
  reason: {{$clientName}}ErrorReason;
  underlyingError?: Error; // Optional field to hold the original error object, if available

  constructor(reason: {{$clientName}}ErrorReason, message: string, error?: Error) {
    super(message);
    this.reason = reason;
    this.underlyingError = error;
    if (error) {
      this.stack = error.stack; // Preserve original stack trace if available
    }
  }
}

export type {{$clientName}}ErrorReason =
  | "invalid_request"
  | "decode_error"
  | "network_error"
  | "other_error";

export const {{$clientName}}ErrorReasonInvalidRequest = "invalid_request";
export const {{$clientName}}ErrorReasonDecodeError = "decode_error";
export const {{$clientName}}ErrorReasonNetworkError = "network_error";
export const {{$clientName}}ErrorReasonOtherError = "other_error";


{{range .Endpoints}}
{{with .Request}}
{{template "requestGenerator" .}}

export function Validate{{.Name}}(req: {{.Name}}) : {{$clientName}}Error | null {
  if (!req) {
    throw new {{$clientName}}Error({{$clientName}}ErrorReasonInvalidRequest, "Request is required");
  }

  {{if .RequestBodyName}}
  // Validate request body
  const bodyValidationError = Validate{{.RequestBodyName}}(req.Body);
  if (bodyValidationError) {
    throw new {{$clientName}}Error({{$clientName}}ErrorReasonInvalidRequest, "Invalid request body: " + bodyValidationError.message, bodyValidationError);
  }
  {{end}}

  {{if .AuthAll}}
  {{range .AuthAll}}
  if (!req.Auth.{{.Name}} || req.Auth.{{.Name}}.trim() === "") {
    throw new {{$clientName}}Error({{$clientName}}ErrorReasonInvalidRequest, "Missing required authentication parameter: {{.TransportName}}");
  }
  {{end}}
  {{end}}

  {{if .AuthAny}}
  var anyAuthParamsPresent = false;
  {{range .AuthAny}}
  if (req.Auth.{{.Name}} && req.Auth.{{.Name}}.trim() !== "") {
    anyAuthParamsPresent = true;
  }
  {{end}}
  if (!anyAuthParamsPresent) {
    throw new {{$clientName}}Error({{$clientName}}ErrorReasonInvalidRequest, "At least one authentication parameter is required: {{range $i, $a := .AuthAny}}{{if $i}}, {{end}}{{.TransportName}}{{end}}");
  }
  {{end}}

  return null;
}

{{range .SupportingTypes}}
function Validate{{.Name}}(o: {{.Name}}) : {{$clientName}}Error | null {
  {{range .Fields}}
  {{if .NonEmpty}}
  {{if .IsArray}}
  if (o.{{.Name}}.length === 0) {
    throw new Error("Field '{{.Name}}' must be non-empty");
  }
  {{else if eq .Type "string"}}
  if (o.{{.Name}}.trim() === "") {
    throw new Error("Field '{{.Name}}' must be non-empty");
  }
  {{end}}
  {{end}}
  {{if and .IsArray .RecurseValidate}}
  for (let idx = 0; idx < o.{{.Name}}.length; idx++) {
    const item = o.{{.Name}}[idx];
    Validate{{.ElemType}}(item);
  }
  {{else if .RecurseValidate}}
  {{if .Required}}
  Validate{{.Type}}(o.{{.Name}});
  {{else}}
  if (o.{{.Name}}) {
    Validate{{.Type}}(o.{{.Name}});
  }
  {{end}}
  {{end}}
  {{end}}
  return null;
}
{{end}}

{{end}}

{{range .Responses}}
{{template "responseGenerator" .}}

export async function New{{.Name}}(resp: Response): Promise<{{.Name}}> {
  var result = {} as {{.Name}};

  {{range .Headers}}
  header{{.Name}} = resp.headers.get("{{.TransportName}}");
  {{if .Required}}
  if (!header{{.Name}}) {
    throw new {{$clientName}}Error({{$clientName}}ErrorReasonDecodeError, "Missing required response header: {{.TransportName}}");
  } else {
    result.{{.Name}} = header{{.Name}};
  }
  {{else}}
  if (header{{.Name}}) {
    result.{{.Name}} = header{{.Name}};
  }
  {{end}}
  {{end}}

  {{if .ResponseBodyName}}
  try {
    const body = await resp.json();
    result.Body = body;
  } catch (err) {
    throw new {{$clientName}}Error({{$clientName}}ErrorReasonDecodeError, "Failed to decode response body", err instanceof Error ? err : new Error(String(err)));
  }
  {{end}}
  return result
}
{{end}}
{{end}}
{{end}}